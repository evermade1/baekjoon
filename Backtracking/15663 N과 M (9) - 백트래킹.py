'''
15663 N과 M (9) - 백트래킹 - Silver II
d는 길이 m의 출력할 배열이다.
v는 처음에 주어진 숫자들이 이전에 사용되었는지 확인하는 배열이다.
사전 증가순서로 출력해야 하기 때문에 배열 l을 정렬해준다.
f(x)는 백트래킹을 진행해주는 함수이다.
x는 배열 d에 들어간 숫자의 개수이다. m개가 채워지면 출력한다.
문제에 중복 불가 조건이 있는데, 우선 이전에 들어간 값이 다시 들어가면 안 되므로
v에서 해당 여부를 판단한다. 이 동시에 배열 d의 같은 위치에 같은 값이 들어간다면
d의 이전까지의 배열이 동일하므로 중복이 된다.
예를 들어, d=[1,2,3]까지 채워진 상태에서 f에 들어왔다고 가정하자.
이번 f에서의 for문에서 방금 4가 d에 들어간 경우,
다음 차례에 다시 4가 들어가게 된다면, v에서는 걸러지지 않았지만 중복된다.
해당 문제는 l을 정렬해 놓았으므로 간단하게 해결할 수 있다.
지금 원소와 바로 전 원소를 비교하여 같지 않으면 중복되지 않게 할 수 있다.
c는 해당 기능을 구현하기 위한 변수로, 이전 원소의 값을 저장한다.
다만 첫 번째 원소는 이전 원소가 없으므로 -1로 초기화한다.
이렇게 v[i]==0, c!=l[i]임을 확인하여 중복 검사를 한 뒤 백트래킹을 진행한다.
d[x]에 값을 추가하고, v를 1로 바꿔준다. f 이후 이전 상태로 돌리고 c를 업데이트한다.
'''
n,m=map(int,input().split())
l=list(map(int,input().split()))
l.sort()
d=[0]*m
v=[0]*n
def f(x):
    if x==m:
        print(*d)
        return
    c=-1
    for i in range(n):
        if v[i]==0 and c!=l[i]:
            d[x]=l[i]
            v[i]=1
            f(x+1)
            d[x]=0
            v[i]=0
            c=l[i]
f(0)
