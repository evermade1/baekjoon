'''
27651 벌레컷 - 누적 합, 이분 탐색 - Gold III
숫자 리스트가 주어지면 이를 머리, 가슴, 배로 삼등분 하는데, 등분된 세 개의 sublist의 sum의 크기가 1 3 2 순서여야 하는 문제이다.
우선 누적합을 저장하는 리스트 d를 만들어 시간을 단축한다.
머리를 원소 하나에서 늘려가면서 for문을 돌린다. i까지가 머리에 해당한다. 삼등분이 가능한 최대의 i값인 n-3까지 진행한다.
첫 번째 이분 탐색은 가슴-배 경계의 upper bound를 찾기 위한 코드이다.
가슴의 크기는 생각하지 않고, 머리와 배의 크기만 비교한다.
i+1~n-1 사이에서 진행하여, 배가 머리보다 클 수 있는 경계의 최댓값을 찾는다.
위에서 찾은 값이 i와 같다면 해당 머리의 크기에서는 조건 만족이 불가능하다는 의미이므로 break한다.
두 번째 이분 탐색은 가슴-배 경계의 lower bound를 찾기 위한 코드이다.
머리의 크기에 관계없이 가슴이 배보다 클 수 있는 경계의 최솟값을 찾는다.
두 탐색에서 구한 값 사이에 경계를 놓으면 무조건 문제에서 원하는 조건을 만족한다.
따라서 두 값 사이에서 가능한 경계의 경우의 수를 취한다. 이 값들을 for문 전체에서 더하여 출력한다.

이분 탐색 두 개에서 1 차이의 값을 설정하는 것이 어려웠다.
기존 이분 탐색은 while s<=e, s=m+1, e=m-1을 사용하는데 반해 조금 달라서 어려움을 겪었다.

마지막에 두 값이 같을 때는 해당 경계에서도 만족하지 않는 결과가 나올 수 있기 때문에 이를 보완하였다.
예를 들어, [1,1,1,1,1]에서 a1,a2가 2가 나오는데, 이 경우 1/2/2가 되기 때문에 불가능하다.
'''
n = int(input())
l = list(map(int, input().split()))
d = [0]*n
t = 0
for i in range(n):  # 누적 합 만들기
  t += l[i]
  d[i] = t
s, e = 0, n-1
ans = 0
for i in range(n-2):  # a를 d[i]로 두고 진행
  a = d[i]
  s, e = i+1, n-1
  while s < e:  # y의 upper bound 찾기 - 최소 여기에는 있어야 a<c 만족.
    m = (s+e)//2
    if t-d[m] <= a:  # c가 a보다 작거나 같은 경우
      e = m
    else:  # c가 a보다 큰 경우
      s = m+1
  a1 = e-1
  if e-1 == i:
    break
  s, e = i+1, e-1
  while s < e:  # y의 lower bound 찾기 - 최소 여기에는 있어야 b>c 만족.
    m = (s+e)//2
    if t-d[m] < d[m]-a:
      e = m
    else:
      s = m+1
  a2 = e
  #print(i, a1, a2)
  if a1 == a2:
    if t-d[a1] < d[a1]-a and a < t-d[a1]:
      ans += 1
  else:
    ans += a1-a2+1
print(ans)
