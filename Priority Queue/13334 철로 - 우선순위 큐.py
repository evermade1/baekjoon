'''
13334 철로 - 우선순위 큐
길이 d만큼에 온전히 넣을 수 있는 선분의 개수를 구하는 문제이다.
어떤 선분의 끝점에 d의 끝점을 맞추는 것이 가장 효율적인 방법이므로
주어진 선분들의 끝점을 기준으로 진행한다.
우선 선분들 중 길이가 d보다 긴 선분들은 제외시킨다.
그리고 끝점 기준으로 정렬시킨다.
for문을 돌려서 heap이 비어있으면 삽입, 하나라도 있으면 다음 task를 실행한다.
1. 맨 앞 원소가 현재 설정된 d 내부에 있는지 확인
2. d 내부에 있는 선분 나올 때까지 전부 pop
3. 현재 d보다 밖에 있다면 앞으로 설정할 d에 대해서도 밖에 있으므로 이제 필요 없음
4. 현재 heap에 들어있는 원소 개수 카운트, 이전까지의 최댓값과 비교
이 과정을 거치면 현재 설정한 d 내부에 있는 선분만 남게 된다.
굳이 끝점을 이용하는 이유는 해당 기준을 만족하는 마지막 선분이
현재 조사하는 점이기 때문에 쉽게 조사할 수 있기 때문이다.
시작점을 이용하는 경우 수동으로 해당 범위 내 선분을 전부 찾아줘야 하지만
끝점을 이용하는 경우 앞의 과정에서 d 내의 선분을 찾을 단서를 만들어 놓을 수 있다.
우선순위 큐를 이용하는 이유는 시간을 줄이기 위함이다.
시작점을 우선순위로 사용하기 때문에 원하는 순서로 나오게 할 수 있다. 
어려워서 거의 못 건드리고 찾아봐서 풀었다. 이해하는 것도 오래 걸렸다. 
'''
import sys
import heapq
input=sys.stdin.readline
n=int(input())
l=[]
for i in range(n):
    k=list(map(int,input().split()))
    k.sort() #숫자 낮은 게 앞에 오도록 정렬 
    l.append(k)
d=int(input())
a=[] #l에서 길이가 d보다 긴 원소들 빼고 만들기 위한 리스트 
for i in range(n): #d보다 작은 원소만 남기기 
    if l[i][1]-l[i][0]<=d:
        a.append(l[i])
a.sort(key=lambda x:x[1]) #둘중 큰 원소가 작은 것부터 정렬 
hq=[]
ans=0
for i in a: #a의 모든 원소에 대해서 
    if not hq: #heapq가 비어있을 경우 
        heapq.heappush(hq,i) #그냥 삽입 
    else:
        while hq[0][0]<i[1]-d: #현재 확인중인 기준값(i)에서 d보다 더 떨어진 원소 다 빼기
            heapq.heappop(hq) #다 빼면 d안에 전부 포함된 원소들만 남음
                                           #현재 기준값의 큰 값이 heap에 포함된 값중 최댓값이므로
                                           #작은 값들만 정리해주면 된다.
            if not hq:
                break
        heapq.heappush(hq,i) #현재 확인중인 기준값은 무조건 포함되므로 바로 삽입 
    ans=max(ans,len(hq))
print(ans)
